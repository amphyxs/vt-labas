%define exit_syscall_id 60

section .text
 
 
; Принимает код возврата и завершает текущий процесс
exit: 
    xor rax, rax
    mov rax, exit_syscall_id
    syscall

; Принимает указатель на нуль-терминированную строку, возвращает её длину
string_length:
    xor rax, rax
    .loop:
        cmp byte[rdi + rax], 0
        je .end
        inc rax
        jmp .loop
    .end:
        ret

; Принимает указатель на нуль-терминированную строку, выводит её в stdout
print_string:
    push rdi                ; сохраняем rdi
    call string_length
    mov rdx, rax            ; длину строки в rdx
    pop rsi                 ; укзатель на начало строки в rsi
    mov rdi, 1              ; дескриптор stdout в rdi
    mov rax, 1              ; 'write' syscall в rax
    syscall
    ret

; Принимает код символа и выводит его в stdout
print_char:
    xor rax, rax
    mov rdx, 1              ; размер, 1 байт, в rdx
    push rdi                ; сохраняем символ в стек
    mov rsi, rsp            ; адрес выводимого символа в стеке помещаем в rsi
    mov rdi, 1      
    mov rax, 1        
    syscall
    pop rdi
    ret

; Переводит строку (выводит символ с кодом 0xA)
print_newline:
    mov rdi, 0xA
    jmp print_char

; Выводит беззнаковое 8-байтовое число в десятичном формате 
; Совет: выделите место в стеке и храните там результаты деления
; Не забудьте перевести цифры в их ASCII коды.
print_uint:
    mov rax, rdi            ; кладём конвертируемое число из rdi в rax
    mov r8, 10              ; делитель, который используется для перевода из 16-СС в 10-СС
    push -1                 ; -1 послужит терминалом для того, что цифры числа в 10-СС закочились
    .loop:
        xor rdx, rdx        ; нужно, так как в div регистр rdx участвует как первая часть делимого 
        div r8              ; в rax - частное, в rdx - остаток, остаток - как раз искомая цифра в 10-СС
        push rdx            ; кладём полученную цифру в стек. TODO: для экономии памяти лучше пушить dx
        cmp rax, 0          ; делим, пока не дойдём до нуля
        jne .loop
    .print_digits:
        pop rax             ; получаем цифру в rax
        cmp ax, -1          ; если встретили терминал -1, то выходим
        je .end
        add ax, '0'         ; конвертируем цифру в ASCII-символ
        mov rdi, rax        ; запоминаем адрес символа в стеке в rdi
        call print_char     ; выводим символ из стека
        jmp .print_digits
    .end:
        ret

; Выводит знаковое 8-байтовое число в десятичном формате 
print_int:
    xor rax, rax
    cmp rdi, 0              ; сравниваем переданное число с 0
    jge .print              ; если оно неотрицательное, сразу выводим
    push rdi                ; сохраняем rdi
    mov dil, '-'            ; иначе, если отрицательное, то выводим знак "-"
    call print_char         ; выводим "-"
    pop rdi                 ; возвращаем число в rdi
    neg rdi                 ; берём число по модулю (т.к. оно отрицательное, смена его знака сделает его положительным)
    .print:
        call print_uint     ; выводим неотрицательное число
    ret

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
string_equals:
    mov rax, 1
    .loop:
        mov r8b, byte[rdi]
        cmp r8b, byte[rsi]
        jne .not_equals
        cmp r8b, 0
        je .end
        inc rdi
        inc rsi
        jmp .loop
    .not_equals:
        xor rax, rax
    .end:
        ret

; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
read_char:
    push 0                  ; выделяем место в стеке под читаемый символ
    mov rdx, 1              ; размер, 1 байт, в rdx
    mov rsi, rsp            ; адрес в стеке, куда читать символ, помещаем в rsi
    mov rdi, 0              ; дескриптор stdin в rdi
    mov rax, 0              ; 'read' syscall в rax
    syscall
    pop rax                 ; считанный символ достаём из стека в rax
    ret

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0xA.
; Останавливается и возвращает 0 если слово слишком большое для буфера
; При успехе возвращает адрес буфера в rax, длину слова в rdx.
; При неудаче возвращает 0 в rax
; Эта функция должна дописывать к слову нуль-терминатор
read_word:
    push r12                            ; эта функция использует callee-saved регистры,
    push r13                            ; поэтому обязана сохранить их
    push r14
    push rdi                            ; запоминаем rdi
    mov r12, rdi
    mov r13, rsi
    mov r14, rcx
    .loop_for_skipping_spaces:
        call read_char
        cmp rax, 0x20                   ; проверки на пробельный символ
        je .loop_for_skipping_spaces
        cmp rax, 0x9
        je .loop_for_skipping_spaces
        cmp rax, 0xA
        je .loop_for_skipping_spaces
        xor rcx, rcx                    ; обнуляем счётчик для последующего цикла
    .loop:                              ; цикл считывания непробельных символов
        inc r14                         ; инкрементируем счётчик
        cmp r14, r13                    ; сравниваем счётчик символов с размером буфера
        jg .failure                     ; если больше, то ошибка
        mov byte[r12], al               ; помещаем считанный символ по адресу указателя в rdi
        cmp rax, 0                      ; если символ пробельный, то выходим
        je .success
        cmp rax, 0x20
        je .success
        cmp rax, 0x9
        je .success
        cmp rax, 0xA
        je .success
        inc r12                         ; увеличиваем указатель
        call read_char              
        jmp .loop
    .failure:
        mov rcx, r14
        dec rcx                         ; нужно, так как первый символ, выходящий за границу буфера, был посчитан
        pop rdi                         ; освобождаем стек
        mov rax, 0                     
        jmp .end
    .success:
        mov rdx, r14
        dec rdx                         ; нужно, так как пробельный символ был тоже посчитан
        pop rax                         ; получаем начало буфера из стека
    .end:
        pop r14
        pop r13
        pop r12
        ret

; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
parse_uint:
    xor rcx, rcx                        ; обнуляем счётчик цифр
    xor rax, rax
    mov r8d, 10                         ; сохраняем константу: множитель для перевода из 10-СС в 16-СС
    .loop:
        mov dl, [rdi]                   ; читааем очередной символ в dl
        test dl, dl                       ; проверка на нуль-терминал
        jz .end                         
        sub dl, '0'                     ; получаем десятичную цифру вычитаением кода символа первой цифры
        cmp dl, 0                       ; если меньше нуля, то это не цифра
        jl .end                         
        cmp dl, 9                       ; если больше 9, то это не цифра
        jg .end
        push rdx                        ; сохраняем rdx
        mul r8                          ; переводим в 10-СС по приницпу: ТЕКУЩИЙ РЕЗУЛЬТАТ*10 + НОВАЯ ЦИФРА
        pop rdx                         ; возвращаем rdx
        add al, dl                      ; прибавляем НОВАЯ ЦИФРА
        inc rcx                         ; увеличиваем счётчик цифр
        inc rdi                         ; переходим к адресу следующего символа
        jmp .loop
    .end:
        mov rdx, rcx
        ret

; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
parse_int:
    mov cl, byte[rdi]                   ; в cl первый символ строки
    cmp cl, '-'                         ; минус ли он
    je .leave_sign
    cmp cl, '+'                         ; плюс ли он
    je .leave_sign
    jmp .parse
    .leave_sign:
        inc rdi                         ; если минус, рассматриваем следующее за ним число
    .parse:
        push rcx                        ; сохраняем rcx
        call parse_uint                 ; парсим просто число как беззнаковое
        pop rcx                         ; возвращаем rcx
        cmp cl, '-'                     ; если первый символ был минусом
        jne .end                        
        neg rax                         ; тогда меняем знак полученного числа
        inc rdx                         ; учитываем, что минус - это тоже символ в числе
    .end:
        ret 

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
string_copy:
    xor rcx, rcx
    .loop:
        mov al, byte[rdi]
        inc rdi                         ; увеличиваем указатель
        inc rcx                         ; инкрементируем счётчик
        cmp rcx, rdx                    ; сравниваем счётчик символов с размером буфера
        jg .failure                     ; если больше, то ошибка
        mov byte[rsi], al               ; помещаем считанный символ по адресу указателя в rsi
        inc rsi
        cmp al, 0                       ; если символ - нуль-терминал, то выходим
        je .success
        jmp .loop
    .failure:
        mov rax, 0                     
        jmp .end
    .success:
        mov rax, rcx                    ; кладём в rax количество символов
    .end:
        ret
