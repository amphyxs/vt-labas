	ORG	0x244
START:	CLA
S1:	IN	0x07	; Спин-луп для чтения состояния готовности с ВУ-3
	AND	#0x40
	BEQ	S1	; Конец
	IN	0x06	; Прочитать первый символ
	SWAM	SIZE	; Получаем значение SIZE в аккумуляторе, сохраняя предыдущее значение в памяти
	INC		; Увеличиваем кол-во символов на 1
	SWAM	SIZE	; Выгружаем SIZE и возвращаем символ
	CMP	#0x0D	; Проверка на стоп-символ, если он найден, то Z=1
	BEQ	SAVE	; При обнаружении стоп-символа не читаем второй символ	
	ST	TEMP	; Временно выгружаем первый символ (он перезапишется в спин-лупе чтения второго символа)
	CLA		; Очищаем аккумулятор для спин-лупа
S2:	IN	0x07	; Спин-луп для чтения состояния готовности с ВУ-3
	AND	#0x40
	BEQ	S2	; Конец
	IN	0x06	; Прочитать второй символ
	SWAM	SIZE	; Получаем значение SIZE в аккумуляторе, сохраняя предыдущее значение в памяти
	INC		; Увеличиваем кол-во символов на 1
	SWAM	SIZE	; Выгружаем SIZE и возвращаем символ
	CMP	#0x0D	; Проверка на стоп-символ, если он найден, то Z=1
	PUSHF		; Сохраняем PS в стек, чтобы NZVC не были утеряны после ADD
	SWAB		; Второй символ в левый байт
	ADD	TEMP	; Возвращаем первый символ в правый байт
	POPF		; Возвращаем состояние NZVC перед командой ADD
SAVE:	ST	(ADDR)+	; Сохранить данные, переместив указатель на следующую ячейку
	BEQ	OUTP	; Стоит Z=1 - значит, был стоп-символ, нужен останов
	JUMP	S1	; Продолжение чтения
OUTP:	LD	-(ADDR)	; Загружаем пару очередных символов
	CMP	ACHR	; Проверяем левую границу
	BLT	SMAL1	; Если левее границы, то проверяем на строчную
	CMP	ZCHR	; Проверяем правую границу
	BGE	SMAL1	; Если правее границы, то проверяем на строчную
	JUMP	PRINT1	; Если прошло проверку, то переходим к выводу
SMAL1:	CMP	A1CH	; Проверяем левую границу строчных
	BLT	NEXT	; Если левее границы, то переходим к следующему
	CMP	Z1CH	; Проверяем правую границу строчных
	BGE	NEXT	; Если правее границы, то переходим к следующему
PRINT1:	SWAB		; Помещаем наш символ в младший байт
	PUSH		; Временно сохраняем наш символ
	CLA
S3:	IN	0x0D	; Спин-луп для чтения состояния готовности с ВУ-5
	AND	#0x40
	BEQ	S3	; Конец
	POP		; Возвращаем символы в аккумулятор
	OUT	0x0C	; Выводим наш символ
	JUMP	CHR2	; Переходим к выводу второго символа без обмена байтов (он уже в старшем байте)
NEXT:	SWAB		; Помещаем второй символ в старший байт	
CHR2:	CMP	ACHR	; Проверяем левую границу
	BLT	SMAL2	; Если левее границы, то проверяем на строчную
	CMP	ZCHR	; Проверяем правую границу
	BGE	SMAL2	; Если правее границы, то проверяем на строчную
	JUMP	PRINT2	; Если прошло проверку, то переходим к выводу
SMAL2:	CMP	A1CH	; Проверяем левую границу строчных
	BLT	END1	; Если левее границы, то переходим к следующему
	CMP	Z1CH	; Проверяем правую границу строчных
	BGE	END1	; Если правее границы, то переходим к следующему
PRINT2:	SWAB		; Помещаем наш символ в младший байт
	PUSH		; Временно сохраняем наш символ
	CLA
S4:	IN	0x0D	; Спин-луп для чтения состояния готовности с ВУ-5
	AND	#0x40
	BEQ	S4	; Конец
	POP		; Возвращаем символы в аккумулятор
	OUT	0x0C	; Выводим наш символ
END1:	LOOP	SIZE	; Проверяем, есть ли у нас ещё символы
	JUMP	OUTP	; Если есть, то продолжаем цикл
	HLT		; Иначе останов

	ORG	0x290
TEMP:	WORD	?	; Ячейка для временного сохранения первого символа
SIZE:	WORD	0x0000	; Ячейка для подсчёта количества введённых символов
ACHR:	WORD	0x4100	; ASCII-код левой границы для больших
ZCHR:	WORD	0x5B00	; ASCII-код правой границы для больших
A1CH:	WORD	0x6100	; ASCII-код левой границы для строчных
Z1CH:	WORD	0x7B00	; ASCII-код правой границы для строчных

	ORG	0x2A0
ADDR:	WORD	0x05AD	; Адрес сохранения символов

;СИМВ:	C	м	е	т	а	н	а	-	CR
;КОИ-8:	F3	CD	C5	D4	C1	CE	C1	2D	0D
;UTF-8: D0A1	D0BC	D0B5	D182	D0B0	D0BD	D0B0	2D	0D
;UTF-16:0421	043C	0435	0442	0430	043D	0430	002D	000D

; I Love ОПД!
; 49 4C 6F 76 65 EF F0 E4 21
; I  L  o  v  e  О  П  Д  !
